# Story 2.1: Work Plan Feature Module Setup

Status: ready-for-dev

<!-- Note: Validation is optional. Run validate-create-story for quality check before dev-story. -->

## Story

As a developer,
I want the work_plan feature module with Clean Architecture structure,
so that the foundation is ready for work plan functionality.

## Acceptance Criteria

1. **Given** the Flutter project
   **When** the work_plan feature is added
   **Then** the folder structure follows Clean Architecture:
   - `lib/features/work_plan/data/` (datasources, models, repositories)
   - `lib/features/work_plan/domain/` (entities, repositories, usecases)
   - `lib/features/work_plan/presentation/` (bloc, pages, widgets)
   **And** barrel file `work_plan.dart` exports public APIs
   **And** DI registration is added to `injection_container.dart`

2. **Given** the work_plan module structure
   **When** a developer imports the feature
   **Then** they can use: `import 'package:fstrack_tractor/features/work_plan/work_plan.dart';`

## Tasks / Subtasks

- [ ] Create folder structure under `lib/features/work_plan/`
  - [ ] data/datasources/
  - [ ] data/models/
  - [ ] data/repositories/
  - [ ] domain/entities/
  - [ ] domain/repositories/
  - [ ] domain/usecases/
  - [ ] presentation/bloc/
  - [ ] presentation/pages/
  - [ ] presentation/widgets/
- [ ] Create domain layer
  - [ ] `work_plan_entity.dart` - Business entity with core fields
  - [ ] `operator_entity.dart` - Operator entity for assignment
  - [ ] `work_plan_repository.dart` - Abstract repository interface
- [ ] Create data layer
  - [ ] `work_plan_model.dart` - Data model with fromJson/toJson
  - [ ] `operator_model.dart` - Operator data model
  - [ ] `work_plan_remote_datasource.dart` - API calls to backend
  - [ ] `work_plan_repository_impl.dart` - Repository implementation
- [ ] Create presentation layer (boilerplate only)
  - [ ] `work_plan_bloc.dart` - BLoC with initial events/states
  - [ ] `work_plan_event.dart` - Event definitions
  - [ ] `work_plan_state.dart` - State definitions
- [ ] Create barrel files
  - [ ] `domain/domain.dart` - Exports domain layer
  - [ ] `data/data.dart` - Exports data layer
  - [ ] `presentation/presentation.dart` - Exports presentation layer
  - [ ] `work_plan.dart` - Main barrel file
- [ ] Register in DI container
  - [ ] Add to `injection_container.dart`
  - [ ] Run `build_runner` to generate injectable code

## Dev Notes

### ⚡ Quick Reference

| Aspect | Value |
|--------|-------|
| Feature Path | `lib/features/work_plan/` |
| Status Values | `OPEN, CLOSED, CANCEL` (production schema) |
| operator_id | INTEGER |
| location_id | VARCHAR(32) |
| unit_id | VARCHAR(16) |
| DI Pattern | `@injectable` annotation + build_runner |

---

### Previous Story Context (From Epic 1)

**Critical: Production Schema Alignment**

Epic 1 (Backend Foundation) confirmed actual production database schema di Bulldozer DB:

| Field | Type | Notes |
|-------|------|-------|
| `schedules.id` | UUID (string) | Auto-generated by backend |
| `schedules.operator_id` | INTEGER nullable | FK ke operators.id (INTEGER) |
| `schedules.location_id` | VARCHAR(32) | FK ke locations.id |
| `schedules.unit_id` | VARCHAR(16) | FK ke units.id |
| `schedules.status` | ENUM | `OPEN, CLOSED, CANCEL` (production values) |

**Key Learnings:**
- ❌ Jangan gunakan UUID untuk operator_id - production pakai INTEGER
- ❌ Jangan gunakan UUID untuk location_id/unit_id - production pakai VARCHAR
- ✅ Status values harus match production: `OPEN, CLOSED, CANCEL`
- ✅ Semua ID fields di Flutter tetap String (meski backend beberapa pakai INTEGER)

**API Pattern Sudah Ada:**
- Base URL dan Dio client sudah dikonfigurasi di `lib/core/network/`
- JWT interceptor sudah aktif (tidak perlu manual header)
- Error handling pattern sudah established

---

### Clean Architecture Structure (MANDATORY)

**NEVER flatten this structure:**

```
lib/features/work_plan/
├── work_plan.dart                    # Barrel file
├── data/
│   ├── data.dart                     # Barrel
│   ├── datasources/
│   │   ├── work_plan_remote_datasource.dart
│   │   └── work_plan_local_datasource.dart
│   ├── models/
│   │   ├── work_plan_model.dart
│   │   └── operator_model.dart
│   └── repositories/
│       └── work_plan_repository_impl.dart
├── domain/
│   ├── domain.dart                   # Barrel
│   ├── entities/
│   │   ├── work_plan_entity.dart
│   │   └── operator_entity.dart
│   ├── repositories/
│   │   └── work_plan_repository.dart
│   └── usecases/
│       ├── create_work_plan_usecase.dart
│       ├── assign_operator_usecase.dart
│       ├── get_work_plans_usecase.dart
│       └── get_operators_usecase.dart
└── presentation/
    ├── presentation.dart             # Barrel
    ├── bloc/
    │   ├── work_plan_bloc.dart
    │   ├── work_plan_event.dart
    │   └── work_plan_state.dart
    ├── pages/
    │   └── work_plan_list_page.dart
    └── widgets/
        ├── work_plan_card.dart
        ├── create_bottom_sheet.dart
        ├── assign_bottom_sheet.dart
        └── status_badge.dart
```

### Existing Pattern References (From Fase 1)

**Follow these existing implementations - Jangan reinvent!**

| Pattern | Reference File | Notes |
|---------|---------------|-------|
| **Entity Structure** | `lib/features/auth/domain/entities/user_entity.dart` | Equatable, fromJson/toJson pattern |
| **Repository Interface** | `lib/features/auth/domain/repositories/auth_repository.dart` | Either<Failure, Success> return type |
| **BLoC Structure** | `lib/features/auth/presentation/bloc/auth_bloc.dart` | Event/State naming convention |
| **Model Pattern** | `lib/features/weather/data/models/weather_model.dart` | fromJson/toJson with field mapping |

**Entity Pattern (from user_entity.dart):**
```dart
class UserEntity extends Equatable {
  final String id;
  final String fullName;
  // ...

  const UserEntity({required this.id, ...});

  factory UserEntity.fromJson(Map<String, dynamic> json) { ... }
  Map<String, dynamic> toJson() { ... }

  @override
  List<Object?> get props => [id, fullName, ...];
}
```

**DI Registration Pattern (Injectable - Not Manual!):**

Project ini menggunakan `get_it` + `injectable` dengan code generation. Jangan registrasi manual!

```dart
// ✅ CORRECT - Use annotations
@lazySingleton
class WorkPlanRemoteDataSourceImpl implements WorkPlanRemoteDataSource {
  WorkPlanRemoteDataSourceImpl(this._dio);
  final Dio _dio;
}

@lazySingleton
class CreateWorkPlanUseCase {
  CreateWorkPlanUseCase(this._repository);
  final WorkPlanRepository _repository;
}

@injectable
class WorkPlanBloc extends Bloc<WorkPlanEvent, WorkPlanState> {
  WorkPlanBloc(@factoryParam this._useCase);
}
```

---

### Entity Fields (from Production Schema)

**WorkPlanEntity:**
```dart
class WorkPlanEntity {
  final String id;                    // UUID - Generated by backend
  final DateTime workDate;            // REQUIRED - Tanggal kerja
  final String pattern;               // REQUIRED - Pola kerja (Rotasi/Non-Rotasi)
  final String shift;                 // REQUIRED - Shift (Pagi/Sore/Malam)
  final String locationId;            // REQUIRED - VARCHAR(32) FK to locations
  final String unitId;                // REQUIRED - VARCHAR(16) FK to units
  final int? operatorId;              // NULLABLE - INTEGER FK to operators (assigned later)
  final String status;                // DEFAULT: "OPEN" - Set by backend on create
  final DateTime? startTime;          // NULLABLE - Filled when work starts
  final DateTime? endTime;            // NULLABLE - Filled when work ends
  final String? reportId;             // NULLABLE - Links to activity report
  final String? notes;                // NULLABLE - Catatan tambahan
  final DateTime createdAt;           // Auto-generated
  final DateTime updatedAt;           // Auto-generated
}
```

**OperatorEntity:**
```dart
class OperatorEntity {
  final int id;                       // INTEGER - Production schema (NOT UUID!)
  final String name;                  // Nama operator
  final bool isActive;                // Status aktif
}
```

> **⚠️ CRITICAL:** `operator_id` di production adalah INTEGER, bukan UUID. Jangan salah tipe data!
> - `operatorId` di Flutter tetap pakai `int` type
> - Tapi saat kirim ke API, pastikan serialization benar

### Repository Interface Pattern

**Standard verbs ONLY:** `get`, `create`, `update`, `delete`

```dart
abstract class WorkPlanRepository {
  Future<Either<Failure, List<WorkPlanEntity>>> getAll();
  Future<Either<Failure, WorkPlanEntity>> getById(String id);
  Future<Either<Failure, WorkPlanEntity>> create(CreateWorkPlanParams params);
  Future<Either<Failure, WorkPlanEntity>> update(String id, UpdateWorkPlanParams params);
  Future<Either<Failure, List<OperatorEntity>>> getOperators();
}
```

### BLoC Pattern Rules

**Event Naming:** `{Action}{Object}{Verb}` (PascalCase)
```dart
// CORRECT
class CreateWorkPlanRequested extends WorkPlanEvent { ... }
class AssignOperatorPressed extends WorkPlanEvent { ... }
class LoadWorkPlansRequested extends WorkPlanEvent { ... }
```

**State Pattern:**
```dart
abstract class WorkPlanState extends Equatable { ... }
class WorkPlanInitial extends WorkPlanState { ... }
class WorkPlanLoading extends WorkPlanState { ... }
class WorkPlanLoaded extends WorkPlanState {
  final List<WorkPlanEntity> workPlans;
}
class WorkPlanError extends WorkPlanState {
  final String message;  // ALWAYS in Bahasa Indonesia
}
```

### Naming Conventions

| Type | Convention | Example | Wrong |
|------|------------|---------|-------|
| Files | snake_case | `work_plan_bloc.dart` | `WorkPlanBloc.dart` |
| Classes | PascalCase | `WorkPlanBloc` | `workPlanBloc` |
| Variables | camelCase | `isLoading` | `is_loading` |
| BLoC Events | PascalCase + Verb | `CreateWorkPlanRequested` | `createWorkPlan` |
| BLoC States | PascalCase | `WorkPlanLoading` | `workPlanLoading` |

### API Endpoints (from Architecture)

| Method | Endpoint | Purpose |
|--------|----------|---------|
| GET | /api/v1/schedules | List work plans |
| POST | /api/v1/schedules | CREATE work plan |
| GET | /api/v1/schedules/:id | Get detail |
| PATCH | /api/v1/schedules/:id | ASSIGN operator |
| GET | /api/v1/operators | List operators |

### JSON Field Mapping

**API uses camelCase:**
```json
{
  "workDate": "2026-01-30",
  "operatorId": 123,
  "locationId": "LOC001"
}
```

**Database uses snake_case:**
```sql
work_date, operator_id, location_id
```

**Model handles conversion in fromJson/toJson**

### Barrel File Pattern

**Each layer must have barrel file:**

```dart
// domain/domain.dart
export 'entities/work_plan_entity.dart';
export 'entities/operator_entity.dart';
export 'repositories/work_plan_repository.dart';
export 'usecases/create_work_plan_usecase.dart';
export 'usecases/get_work_plans_usecase.dart';
export 'usecases/assign_operator_usecase.dart';
export 'usecases/get_operators_usecase.dart';
```

```dart
// work_plan.dart (main barrel)
export 'data/data.dart';
export 'domain/domain.dart';
export 'presentation/presentation.dart';
```

### DI Registration (Injectable Pattern)

**Gunakan annotations - Jangan registrasi manual!**

Tambahkan annotations ke class definitions:

```dart
// Data Layer
@lazySingleton
class WorkPlanRemoteDataSourceImpl implements WorkPlanRemoteDataSource {
  WorkPlanRemoteDataSourceImpl(this._dio);
  final Dio _dio;
}

@lazySingleton
class WorkPlanRepositoryImpl implements WorkPlanRepository {
  WorkPlanRepositoryImpl(this._remoteDataSource);
  final WorkPlanRemoteDataSource _remoteDataSource;
}

// Domain Layer
@lazySingleton
class CreateWorkPlanUseCase {
  CreateWorkPlanUseCase(this._repository);
  final WorkPlanRepository _repository;
}

@lazySingleton
class GetWorkPlansUseCase {
  GetWorkPlansUseCase(this._repository);
  final WorkPlanRepository _repository;
}

@lazySingleton
class AssignOperatorUseCase {
  AssignOperatorUseCase(this._repository);
  final WorkPlanRepository _repository;
}

@lazySingleton
class GetOperatorsUseCase {
  GetOperatorsUseCase(this._repository);
  final WorkPlanRepository _repository;
}

// Presentation Layer
@injectable
class WorkPlanBloc extends Bloc<WorkPlanEvent, WorkPlanState> {
  WorkPlanBloc(
    this._createUseCase,
    this._getWorkPlansUseCase,
    this._assignUseCase,
    this._getOperatorsUseCase,
  ) : super(WorkPlanInitial()) {
    // Event handlers
  }

  final CreateWorkPlanUseCase _createUseCase;
  final GetWorkPlansUseCase _getWorkPlansUseCase;
  final AssignOperatorUseCase _assignUseCase;
  final GetOperatorsUseCase _getOperatorsUseCase;
}
```

**Then run:** `flutter pub run build_runner build --delete-conflicting-outputs`

> **Note:** File `injection_container.config.dart` akan auto-generate. Jangan edit manual!

### Error Handling Pattern

**Repository returns Either<Failure, Success>:**

```dart
Future<Either<Failure, WorkPlanEntity>> create(CreateWorkPlanParams params) async {
  try {
    final result = await remoteDataSource.create(params);
    return Right(result);
  } on ServerException catch (e) {
    return Left(ServerFailure(e.message));
  } catch (e) {
    return Left(ServerFailure('Gagal membuat rencana kerja'));
  }
}
```

**Error messages in Bahasa Indonesia:**
- "Gagal memuat rencana kerja" (Failed to load)
- "Gagal membuat rencana kerja" (Failed to create)
- "Gagal menugaskan operator" (Failed to assign)
- "Semua field wajib diisi" (Validation error)

### Project Structure Notes

**Alignment with unified project structure:**
- Feature location: `lib/features/work_plan/` (NEW)
- Follows existing pattern: `lib/features/auth/`, `lib/features/home/`, `lib/features/weather/`
- Core utilities in: `lib/core/`
- Shared widgets in: `lib/shared/widgets/`

**No conflicts expected** - this is a new feature module that doesn't modify existing files.

### References

- [Source: project-context.md] - Clean Architecture rules, naming conventions, BLoC patterns, Injectable DI pattern
- [Source: architecture.md#step-6] - Complete project structure reference
- [Source: epics.md#story-21] - Story requirements and acceptance criteria
- [Source: docs/schema-reference.md] - Production database schema (operator_id INTEGER, location_id VARCHAR(32), unit_id VARCHAR(16))
- [Reference: lib/features/auth/domain/entities/user_entity.dart] - Entity pattern with Equatable
- [Reference: lib/features/weather/data/models/weather_model.dart] - Model pattern with fromJson/toJson

## Dev Agent Record

### Agent Model Used

{{agent_model_name_version}}

### Debug Log References

### Completion Notes List

### File List

**New Files to Create (24 files):**

| # | Layer | File Path | Purpose |
|---|-------|-----------|---------|
| 1 | Root | `lib/features/work_plan/work_plan.dart` | Main barrel file |
| 2 | Data | `lib/features/work_plan/data/data.dart` | Data layer barrel |
| 3 | Data | `lib/features/work_plan/data/datasources/work_plan_remote_datasource.dart` | API calls |
| 4 | Data | `lib/features/work_plan/data/datasources/work_plan_local_datasource.dart` | Local cache |
| 5 | Data | `lib/features/work_plan/data/models/work_plan_model.dart` | Data model |
| 6 | Data | `lib/features/work_plan/data/models/operator_model.dart` | Operator model |
| 7 | Data | `lib/features/work_plan/data/repositories/work_plan_repository_impl.dart` | Repository impl |
| 8 | Domain | `lib/features/work_plan/domain/domain.dart` | Domain layer barrel |
| 9 | Domain | `lib/features/work_plan/domain/entities/work_plan_entity.dart` | Work plan entity |
| 10 | Domain | `lib/features/work_plan/domain/entities/operator_entity.dart` | Operator entity |
| 11 | Domain | `lib/features/work_plan/domain/repositories/work_plan_repository.dart` | Abstract repository |
| 12 | Domain | `lib/features/work_plan/domain/usecases/create_work_plan_usecase.dart` | Create use case |
| 13 | Domain | `lib/features/work_plan/domain/usecases/get_work_plans_usecase.dart` | Get list use case |
| 14 | Domain | `lib/features/work_plan/domain/usecases/assign_operator_usecase.dart` | Assign use case |
| 15 | Domain | `lib/features/work_plan/domain/usecases/get_operators_usecase.dart` | Get operators use case |
| 16 | Presentation | `lib/features/work_plan/presentation/presentation.dart` | Presentation barrel |
| 17 | Presentation | `lib/features/work_plan/presentation/bloc/work_plan_bloc.dart` | BLoC logic |
| 18 | Presentation | `lib/features/work_plan/presentation/bloc/work_plan_event.dart` | Events |
| 19 | Presentation | `lib/features/work_plan/presentation/bloc/work_plan_state.dart` | States |
| 20 | Presentation | `lib/features/work_plan/presentation/pages/work_plan_list_page.dart` | Placeholder page |
| 21 | Presentation | `lib/features/work_plan/presentation/widgets/work_plan_card.dart` | Placeholder widget |
| 22 | Presentation | `lib/features/work_plan/presentation/widgets/create_bottom_sheet.dart` | Placeholder widget |
| 23 | Presentation | `lib/features/work_plan/presentation/widgets/assign_bottom_sheet.dart` | Placeholder widget |
| 24 | Presentation | `lib/features/work_plan/presentation/widgets/status_badge.dart` | Placeholder widget |

**Files Modified:**
- `lib/injection_container.config.dart` - Auto-generated by build_runner (jangan edit manual!)

**Commands to Run:**
```bash
# Generate DI code (setelah semua annotations ditambahkan)
flutter pub run build_runner build --delete-conflicting-outputs

# Verify no issues
flutter analyze  # Must show "No issues found!"

# Run tests
flutter test
```

---

### Schema Alignment Notes

**✅ CONFIRMED - Production Schema (Epic 1):**

| Field | Production Type | Flutter Type | Notes |
|-------|-----------------|--------------|-------|
| `schedules.id` | UUID | `String` | Backend-generated |
| `schedules.operator_id` | INTEGER | `int?` | Nullable until assigned |
| `schedules.location_id` | VARCHAR(32) | `String` | Manual ID |
| `schedules.unit_id` | VARCHAR(16) | `String` | Manual ID |
| `schedules.status` | ENUM | `String` | `OPEN, CLOSED, CANCEL` |
| `operators.id` | INTEGER | `int` | Auto-increment |

**❌ REJECTED - Values NOT in production:**
- `ASSIGNED` status - Production pakai `CLOSED` setelah operator ditugaskan
- `IN_PROGRESS` status - Fase 3 feature, belum ada di production
- `COMPLETED` status - Fase 3 feature, belum ada di production

**State Machine (Production Behavior):**
```
OPEN → CLOSED (when operator assigned)
OPEN → CANCEL (cancellation)
```

**UI Display Mapping (IMPORTANT - Avoid Confusion):**

Meski backend pakai `CLOSED`, di UI Flutter harus ditampilkan sebagai "Ditugaskan" (bukan "Closed"):

```dart
String getStatusDisplayText(String backendStatus) {
  return switch (backendStatus) {
    'OPEN' => 'Terbuka',
    'CLOSED' => 'Ditugaskan',  // NOT "Ditutup" - avoid confusion!
    'CANCEL' => 'Dibatalkan',
    _ => backendStatus,
  };
}
```

**Why:** `CLOSED` di database artinya "sudah ada operator", bukan "pekerjaan selesai". Jangan bikin user bingung!

**PENTING:** Jangan implementasikan status values selain `OPEN, CLOSED, CANCEL` karena akan menyebabkan error saat komunikasi dengan backend production.
